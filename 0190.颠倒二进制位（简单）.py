"""
颠倒给定的 32 位无符号整数的二进制位。

提示：

请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。
在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在 示例 2 中，输入表示有符号整数 -3，输出表示有符号整数 -1073741825。
"""

class Solution:
    def reverseBits(self, n: int) -> int:


        # 方法一：位运算
        # 时间复杂度：O(logn)
        # 空间复杂度：O(1)
        res = 0

        for i in range(32):
            #print('i:', i)
            #print('res before:', bin(res))
            #print('n:', bin(n))
            #print('n & 1:', n & 1)
            res |= (n & 1)
            if i != 31:
                res <<= 1
            #print('res aft:', bin(res))
            n >>= 1

        return res


        # 方法二：位运算2
        # 时间复杂度：O(logn)
        # 空间复杂度：O(1)
        res = 0

        for i in range(32):
            #print('i:', i)
            #print('res before:', bin(res))
            #print('n:', bin(n))
            #print('n & 1:', n & 1)
            res |= (n & 1) << (31-i)
            #print('res aft:', bin(res))
            n >>= 1

        return res


        # 方法三：分治法
        # 时间复杂度：O(1)
        # 空间复杂度：O(1)
        n1 = 0b01010101010101010101010101010101  # 二进制数
        n2 = 0b00110011001100110011001100110011
        n3 = 0b00001111000011110000111100001111
        n4 = 0b00000000111111110000000011111111
        n5 = 0b00000000000000001111111111111111

        n = ((n >> 1) & n1) | ((n & n1) << 1)
        n = ((n >> 2) & n2) | ((n & n2) << 2)
        n = ((n >> 4) & n3) | ((n & n3) << 4)
        n = ((n >> 8) & n4) | ((n & n4) << 8)
        n = ((n >> 16) & n5) | ((n & n5) << 16)

        #print(n)
        return n
        #return (n >> 16) | (n << 16)







