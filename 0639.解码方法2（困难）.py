"""
一条包含字母 A-Z 的消息通过以下的方式进行了编码：

'A' -> 1
'B' -> 2
...
'Z' -> 26
要 解码 一条已编码的消息，所有的数字都必须分组，然后按原来的编码方案反向映射回字母（可能存在多种方式）。例如，"11106" 可以映射为：

"AAJF" 对应分组 (1 1 10 6)
"KJF" 对应分组 (11 10 6)

注意，像 (1 11 06) 这样的分组是无效的，因为 "06" 不可以映射为 'F' ，因为 "6" 与 "06" 不同。
除了 上面描述的数字字母映射方案，编码消息中可能包含 '*' 字符，可以表示从 '1' 到 '9' 的任一数字（不包括 '0'）。例如，编码字符串 "1*" 可以表示 "11"、"12"、"13"、"14"、"15"、"16"、"17"、"18" 或 "19" 中的任意一条消息。对 "1*" 进行解码，相当于解码该字符串可以表示的任何编码消息。

给你一个字符串 s ，由数字和 '*' 字符组成，返回 解码 该字符串的方法 数目 。
由于答案数目可能非常大，返回对 109 + 7 取余 的结果。

"""

class Solution:
    def numDecodings(self, s: str) -> int:


        # 方法一：动态规划
        # 时间复杂度：O(n)
        # 空间复杂度：O(n)
        MOD = 10 ** 9 + 7
        n = len(s)
        if s[0] == '0':
            return 0

        dp = [0] * (n+1)
        dp[1] = 9 if s[0] == '*' else 1
        dp[0] = 1
        #print(dp)

        for i in range(2, n+1):
            if s[i-1] == '*' and s[i-2] == '*':
                dp[i] += dp[i-2] * 15 
                dp[i] += dp[i-1] * 9

            elif s[i-2] == '*':
                if s[i-1] == '0':
                    dp[i] += dp[i-2] * 2
                elif 0 < int(s[i-1]) < 7:
                    dp[i] += dp[i-2] * 2
                    dp[i] += dp[i-1] 
                elif int(s[i-1]) > 6:
                    dp[i] += dp[i-2] * 1
                    dp[i] += dp[i-1]

            elif s[i-1] == '*':               
                if s[i-2] == '1':
                    dp[i] += dp[i-2] * 9
                    dp[i] += dp[i-1] * 9
                elif s[i-2] == '2':
                    dp[i] += dp[i-2] * 6
                    dp[i] += dp[i-1] * 9
                else:
                    dp[i] += dp[i-1] * 9

            else:    
                if int(s[i-2] + s[i-1]) == 0:  # 连续两个0无法分割
                    return 0
                if s[i-2] != '0' and int(s[i-2] + s[i-1]) <= 26:
                    dp[i] += dp[i-2]
                if s[i-1] != '0':
                    dp[i] += dp[i-1]

            dp[i] %= MOD

        #print(dp)
        return dp[n] 
        




