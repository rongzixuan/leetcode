"""
你还记得那条风靡全球的贪吃蛇吗？

我们在一个 n*n 的网格上构建了新的迷宫地图，蛇的长度为 2，也就是说它会占去两个单元格。蛇会从左上角（(0, 0) 和 (0, 1)）开始移动。我们用 0 表示空单元格，用 1 表示障碍物。蛇需要移动到迷宫的右下角（(n-1, n-2) 和 (n-1, n-1)）。

每次移动，蛇可以这样走：
如果没有障碍，则向右移动一个单元格。并仍然保持身体的水平／竖直状态。
如果没有障碍，则向下移动一个单元格。并仍然保持身体的水平／竖直状态。
如果它处于水平状态并且其下面的两个单元都是空的，就顺时针旋转 90 度。蛇从（(r, c)、(r, c+1)）移动到 （(r, c)、(r+1, c)）。
如果它处于竖直状态并且其右面的两个单元都是空的，就逆时针旋转 90 度。蛇从（(r, c)、(r+1, c)）移动到（(r, c)、(r, c+1)）。

返回蛇抵达目的地所需的最少移动次数。

如果无法到达目的地，请返回 -1。

示例 1：
输入：grid = [[0,0,0,0,0,1],
               [1,1,0,0,1,0],
               [0,0,0,0,1,1],
               [0,0,1,0,1,0],
               [0,1,1,0,0,0],
               [0,1,1,0,0,0]]
输出：11
解释：
一种可能的解决方案是 [右, 右, 顺时针旋转, 右, 下, 下, 下, 下, 逆时针旋转, 右, 下]。

示例 2：
输入：grid = [[0,0,1,1,1,1],
               [0,0,0,0,1,1],
               [1,1,0,0,0,1],
               [1,1,1,0,0,1],
               [1,1,1,0,0,1],
               [1,1,1,0,0,0]]
输出：9

提示：
2 <= n <= 100
0 <= grid[i][j] <= 1
蛇保证从空单元格开始出发。

"""

class Solution:
    def minimumMoves(self, grid: List[List[int]]) -> int:


        # 方法一：广度优先搜索
        # 时间复杂度：O(n^2)
        # 空间复杂度：O(n^2)
        n = len(grid)
        p1, p2 = [0, 0], [0, 1]
        queue = [(p1, p2, 0, -1)]
        used = {(0, 0, 0, 1)}
        while queue:
            for _ in range(len(queue)):
                p1, p2, dist, tp = queue.pop(0)
                #print('p1, p2, dist:', p1, p2, dist, tp)
                if p1[0] ==  n - 1 and p1[1] == n - 2 and p2[0] == n - 1 and p2[1] == n - 1:
                    return dist
                # 向右移动
                if p2[1] + 1 < n and (p1[0], p1[1] + 1, p2[0], p2[1] + 1) not in used and grid[p1[0]][p1[1] + 1] == 0 and grid[p2[0]][p2[1] + 1] == 0:
                    queue.append(([p1[0], p1[1] + 1], [p2[0], p2[1] + 1], dist + 1, "right"))
                    used.add((p1[0], p1[1] + 1, p2[0], p2[1] + 1))
                # 向下移动
                if p2[0] + 1 < n and (p1[0] + 1, p1[1], p2[0] + 1, p2[1]) not in used and grid[p1[0] + 1][p1[1]] == 0 and grid[p2[0] + 1][p2[1]] == 0:
                    queue.append(([p1[0] + 1, p1[1]], [p2[0] + 1, p2[1]], dist + 1, "down"))
                    used.add((p1[0] + 1, p1[1], p2[0] + 1, p2[1]))
                # 水平的顺时针旋转
                if p1[0] == p2[0] and p2[0] + 1 < n and (p1[0], p1[1], p1[0] + 1, p1[1]) not in used and grid[p2[0] + 1][p2[1]] == 0 and grid[p1[0] + 1][p1[1]] == 0:
                    queue.append(([p1[0], p1[1]], [p1[0] + 1, p1[1]], dist + 1, "cl"))
                    used.add((p1[0], p1[1], p1[0] + 1, p1[1]))
                # 竖直的逆时针旋转
                if p1[1] == p2[1] and p2[1] + 1 < n and (p1[0], p1[1], p1[0], p1[1] + 1) not in used and grid[p2[0]][p2[1] + 1] == 0 and grid[p1[0]][p1[1] + 1] == 0:
                    queue.append(([p1[0], p1[1]], [p1[0], p1[1] + 1], dist + 1, "ccl"))
                    used.add((p1[0], p1[1], p1[0], p1[1] + 1))
        return -1


        # 方法二：广度优先搜索
        # 时间复杂度：O(n^2)
        # 空间复杂度：O(n^2)
        step, n = 1, len(grid)
        vis = {(0, 0, 0)}
        q = [(0, 0, 0)]  # 初始位置
        while q:
            tmp = q
            q = []
            for X, Y, S in tmp:
                for t in (X + 1, Y, S), (X, Y + 1, S), (X, Y, S ^ 1):  # 直接把移动后的位置算出来
                    x, y, s = t
                    x2, y2 = x + s, y + (s ^ 1)  # 蛇头
                    if x2 < n and y2 < n and t not in vis and \
                       grid[x][y] == 0 and grid[x2][y2] == 0 and (s == S or grid[x + 1][y + 1] == 0):
                        if x == n - 1 and y == n - 2:  # 此时蛇头一定在 (n-1,n-1)
                            return step
                        vis.add(t)
                        q.append(t)
            step += 1
        return -1


